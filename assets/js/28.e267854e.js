(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{375:function(v,_,i){"use strict";i.r(_);var a=i(43),t=Object(a.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("h1",{attrs:{id:"缓存"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[v._v("#")]),v._v(" 缓存")]),v._v(" "),i("p",[v._v("浏览器缓存机制")]),v._v(" "),i("h2",{attrs:{id:"缓存位置"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[v._v("#")]),v._v(" 缓存位置")]),v._v(" "),i("ul",[i("li",[v._v("Service Worker：运行在浏览器背后的独立线程，一般用来实现缓存。\n"),i("ol",[i("li",[v._v("无法操作DOM")]),v._v(" "),i("li",[v._v("只能使用HTTPS")]),v._v(" "),i("li",[v._v("拦截全站请求从而控制应用")]),v._v(" "),i("li",[v._v("独立于主线程")]),v._v(" "),i("li",[v._v("完全异步，无法使用 XHR 和 LocalStorage")]),v._v(" "),i("li",[v._v("一旦被 install，就永远存在，除非手动删除")]),v._v(" "),i("li",[v._v("独立上下文")]),v._v(" "),i("li",[v._v("响应推送")]),v._v(" "),i("li",[v._v("后台同步")])])]),v._v(" "),i("li",[v._v("Memory Cache：内存中的缓存。")]),v._v(" "),i("li",[v._v("Disk Cache：硬盘中的缓存。")]),v._v(" "),i("li",[v._v("Push Cache：推送缓存（HTTP 2.0 的内容【服务器推送】）。")])]),v._v(" "),i("hr"),v._v(" "),i("h2",{attrs:{id:"强缓存"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[v._v("#")]),v._v(" 强缓存")]),v._v(" "),i("p",[v._v("定义：不会向服务器发送请求，直接从本地缓存中读取资源，状态码为200。")]),v._v(" "),i("p",[v._v("HTTP Header 包含强缓存的字段")]),v._v(" "),i("ol",[i("li",[v._v("Expires"),i("br"),v._v("\nHTTP 1.0 产物，指定缓存的过期时间。")])]),v._v(" "),i("ul",[i("li",[v._v("缺点：受限于本地时间，如果修改了本地时间，可能会造成缓存失效。")])]),v._v(" "),i("ol",{attrs:{start:"2"}},[i("li",[v._v("cache-control"),i("br"),v._v("\nHTTP 1.1 产物，请求返回时间的 n 秒内再次加载资源，就会命中强缓存。"),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[v._v("  指令：\n  public：所有内容都可被缓存（客户端和代理服务器都可缓存）。\n  private：所有内容只有客户端可以缓存\n  no-cache：不使用强缓存，缓存策略由协商缓存接管。\n  no-store：不使用强缓存和协商缓存。\n  max-age：max-age=n 表示缓存内容在 n 秒后失效。\n")])])])]),v._v(" "),i("li",[v._v("两者对比")])]),v._v(" "),i("ul",[i("li",[v._v("Expires 是HTTP 1.0 的产物，cache-control 是 HTTP 1.1的产物；")]),v._v(" "),i("li",[v._v("cache-control 优先级高于 Expires。")])]),v._v(" "),i("hr"),v._v(" "),i("h2",{attrs:{id:"协商缓存"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[v._v("#")]),v._v(" 协商缓存")]),v._v(" "),i("p",[v._v("定义：强制缓存失效后，浏览器向服务器发送携带缓存标识的请求，由服务器决定浏览器是否缓存。")]),v._v(" "),i("p",[v._v("HTTP Header 包含强缓存的字段")]),v._v(" "),i("p",[i("strong",[v._v("Last-Modified、If-Modified-Since")])]),v._v(" "),i("ol",[i("li",[v._v("浏览器第一次访问时，服务器返回资源时在相应头里添加 Last-Modified 字段，值为该资源在服务器上的最后修改时间；")]),v._v(" "),i("li",[v._v("浏览器下次访问该资源时，将上次返回的 Last-Modified 的值 放在 If-Modified-Since 字段里；")]),v._v(" "),i("li",[v._v("服务器收到 If-Modified-Since 的值，与对应的资源的最后修改时间做对比;")]),v._v(" "),i("li",[v._v("如果没有变化，返回 304 和空的响应体，告诉浏览器直接从缓存读取;")]),v._v(" "),i("li",[v._v("如果小于最后的修改时间，返回 200 和新的资源，并更新 Last-Modified。")])]),v._v(" "),i("p",[i("strong",[v._v("缺点")]),v._v("：\n1. 一些文件周期性地更改，但是内容不变，会导致 Last-Modified 的时间修改；\n2. If-Modified-Since 能检查到的精度是秒级的，文件如果在秒以下的时间进行修改，这种修改无法判断。")]),v._v(" "),i("p",[i("strong",[v._v("Etag、If-None-Match")])]),v._v(" "),i("ol",[i("li",[v._v("Etag 是服务器响应请求时，由服务器省省当前资源的一个唯一标识符并返回，只要有资源变化，Etag就会重新生成；")]),v._v(" "),i("li",[v._v("浏览器下次访问该资源时，将上次返回的 Etag 的值放在 If-None-Match 字段里；")]),v._v(" "),i("li",[v._v("服务器收到 If-None-Match 的值，与对应资源的 Etag 做对比;")]),v._v(" "),i("li",[v._v("如果一样，则返回 304 和空的响应体，告诉浏览器直接从缓存读取;")]),v._v(" "),i("li",[v._v("如果不一样，返回 200 和新的资源，并更新 Etag。")])]),v._v(" "),i("ul",[i("li",[v._v("两者对比\n"),i("ol",[i("li",[v._v("精确度上，Etag 要优于 Last-Modified，注：负载均衡的服务器上，各个服务器生成的 Last-Modified 有可能不一致；")]),v._v(" "),i("li",[v._v("性能上，Last-Modified 要优于 Etag，因为 Last-Modified 只记录时间，Etag 需要计算文件的 hash 值；")]),v._v(" "),i("li",[v._v("如果同时存在，Etag 优先级于  Last-Modified；")]),v._v(" "),i("li",[v._v("应用场景上，Last-Modified 偏向于时间状态， Etag 偏向于资源是否有变更。")])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);