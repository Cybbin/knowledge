(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{361:function(t,a,s){"use strict";s.r(a);var r=s(43),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"异步渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步渲染"}},[t._v("#")]),t._v(" 异步渲染")]),t._v(" "),s("h2",{attrs:{id:"为什么要异步渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要异步渲染"}},[t._v("#")]),t._v(" 为什么要异步渲染")]),t._v(" "),s("p",[s("strong",[t._v("提高性能")]),t._v("。")]),t._v(" "),s("ol",[s("li",[t._v("如果不采用异步渲染，在同一个 "),s("code",[t._v("watcher")]),t._v(" 里同步进行多次数据的修改时，会对当前组件进行多次渲染，造成性能浪费。")]),t._v(" "),s("li",[t._v("而如果采用异步渲染，在同一个 "),s("code",[t._v("watcher")]),t._v(" 里同步进行多次数据的修改时，将渲染在异步队列里，会减少渲染的次数。")])]),t._v(" "),s("h2",{attrs:{id:"原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),s("img",{attrs:{src:t.$withBase("/assets/vue/start/async-render.jpg")}})])}),[],!1,null,null,null);a.default=e.exports}}]);